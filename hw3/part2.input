zero = \s.\z. z;;
one = \s.\z. s z;;
succ = \n.\s.\z. s (n s z);;
two = succ one;;
two SUCC ZERO;;
add = \n.\m.\s.\z. m s (n s z);;
four = add two two;;
four SUCC ZERO;;
four_again = multiply two two;;
four_again SUCC ZERO;;
multiply = \n.\m.\s.\z. m (n s) z;;
pair = \x. \y. \f. f x y;;
fst = \p. p (\x. \y. x);;
snd = \p. p (\x. \y. y);;

oo = pair one one;;
ss = \p. pair (multiply (fst p) (snd p)) (succ (snd p));;

factorial = \n. fst (n ss oo);;

recoo = \n. pair n zero;;
recss = \f. \p. pair (f (snd p) (fst p)) (succ (snd p));;

natrec = \f.\n.\m. fst (m (recss f) (recoo n));;

factorial_again = \n. natrec (\p.\q. multiply (succ p) q) one n;;
factorial_again four S Z;;

predoo = pair zero zero;;
predss = \p. pair (succ (fst p)) (fst p);;

pred = \n. snd (n predss predoo);;

three = pred four;;

true = \t.\f. t;;
false = \t.\f. f;;
ite = \cond.\x.\y. cond x y;;
is_zero = \n. n (\m. false) true;;

is_zero four TRUE FALSE;;

Z = \f. (\x. f (\y. x x y)) (\x. f (\y. x x y));;

ff = \self.\x. is_zero x one (multiply x (self (pred x)));;

factorial_yet_again = Z almost_fact;;

(* `snd` works since essentially, a pair is a combinator that receives two arguments as the `car` and `cdr` of the pair and a projection function `f` as the "destructor". So in `fst`, the projection function receives two arguments and returns the first one (which is `x` in `pair`) and conversely, `snd` receives two arguments and returns the second one, which is `cdr` (`y`) in `pair` *)

