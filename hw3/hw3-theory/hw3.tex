\documentclass{article}

\usepackage{lmodern}
\usepackage{concrete}
\usepackage{eulervm}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage[shortlabels]{enumitem}
\usepackage{listings}

% copied from package braket
% edited to remove whitespace inside braces
% and to simplify the definition of \Set because we don't use double-vert
{\catcode`\|=\active
  \xdef\set{\protect\expandafter\noexpand\csname set \endcsname}
  \expandafter\gdef\csname set \endcsname#1{\mathinner
    {\lbrace{\mathcode`\|32768\let|\midvert #1}\rbrace}}
  \xdef\Set{\protect\expandafter\noexpand\csname Set \endcsname}
  \expandafter\gdef\csname Set \endcsname#1{\left\{%
     {\mathcode`\|32768\let|\SetVert #1}\right\}}
}
\def\midvert{\egroup\mid\bgroup}
\makeatletter
\def\mid@vertical{\mskip1mu\vrule\mskip1mu}
\def\SetVert{{\egroup\;\mid@vertical\;\bgroup}}
\makeatother


\lstdefinelanguage{imp}
{morekeywords={while,assert,skip,failed},
sensitive=true,
morecomment=[l]{//},
morestring=[b]",
}
\lstset{
language=imp,
basicstyle=\ttfamily,
keywordstyle=\bfseries,
identifierstyle=,
showstringspaces=false}


\newtheorem{theorem}{Theorem}

\usepackage[margin=1in]{geometry}
\usepackage{changepage}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[C]{Homework 3: Theory part}
\fancyhead[R]{CSE 490P}
\setlength{\headheight}{14pt}
\newcommand{\meta}[1]{{\color{blue}#1}}
\newcommand{\todo}[1]{{\huge\color{red}#1}}
\newcommand{\imp}{\textsc{Imp}}
\newcommand{\stlc}{\textsc{STLC}}
\newcommand{\dom}[1]{\ensuremath{\text{dom}\ #1}}

%\skip is already a LaTeX command, so we pick another name
\newcommand{\progtext}[1]{\ensuremath{\text{\ttfamily\bfseries #1}}}
\newcommand{\impskip}{\progtext{skip}}
\newcommand{\assert}{\progtext{assert}}
\newcommand{\failed}{\progtext{failed}}
\newcommand{\while}{\progtext{while}}
\newcommand{\assign}{\ensuremath{\mathrel{\text{\texttt{:=}}}}}
\newcommand{\progif}{\progtext{if}}
\newcommand{\progthen}{\progtext{then}}
\newcommand{\progelse}{\progtext{else}}
\newcommand{\progtrue}{\progtext{true}}
\newcommand{\progfalse}{\progtext{false}}

\begin{document}

\noindent The last page of this document contains a reference for \stlc{} with booleans.

\section*{Problems from after Lecture on Wednesday 4/15}

\begin{enumerate}[leftmargin=*,itemindent=*,start=1,label={{\bf Problem \arabic*}.},ref=\arabic*]
\item Consider the following statement.
  \begin{quote}
    If $\cdot\vdash\meta{e}:\meta{\tau}$ then $\meta{e}$ is closed.
  \end{quote}
  \begin{enumerate}[(a)]
  \item Enumerate all the things you could try to induct on. Say which ones are reasonable choices. 
    \textbf{$\cdot\vdash\meta{e}:\meta{\tau}$, $\meta{\tau}$ or $\meta{e}$. $\cdot\vdash\meta{e}:\meta{\tau}$ and $\meta{e}$ are reasonable choices}
  \item For the most reasonable choice (your choice!) of thing to induct on, say
    why the direct proof by induction will not work. Be specific.
    
    \textbf{I choose to induct on $\cdot\vdash\meta{e}:\meta{\tau}$. When proceeding at the case $\inferrule{\lbrack \meta{x}\mapsto \meta{\tau_1}\rbrack \vdash \meta{e}:\meta{\tau_2}}{\cdot \vdash\lambda \meta{x}.\meta{e}:\meta{\tau_1}\to\meta{\tau_2}}$, I cannot apply the induction hypothesis on $\meta{e}$ since we are assuming an empty context $\Gamma$}

  \item State a stronger lemma and prove it by induction on a thing of your
    choice. Be sure to state your strengthened lemma clearly. Also, explain
    briefly and informally why your strengthening is, in fact, stronger than the
    statement above.

    \textbf{For all $\meta{e}$, $\meta{x}$ and context $\meta{\Gamma}$, if $\meta{x} \in FV(\meta{e})$ and $\meta{\Gamma}\vdash\meta{e} :\meta{\tau}$ for some type $\meta{\tau}$, then there exists a type $\meta{\tau^\prime}$ such that $\meta{\Gamma}\vdash \meta{x} : \meta{\tau^\prime}$ }
    \begin{proof}
        By induction on $FV(\meta{e})$.
        \begin{enumerate}
          \item Case $FV(\meta{b})=\emptyset$. This case $\meta{e}$ does not have any free variable, thus this case is vacuous.
          \item Case $FV(\meta{x})=\set{\meta{x}}$. In this case, $\meta{e}$ is $\meta{x}$. Since $\meta{\Gamma}\vdash \meta{e} :\meta{\tau}$, exists $\meta{\tau^\prime}=\meta{\tau}$ such that $\meta{\Gamma}\vdash\meta{x}:\meta{\tau^\prime}$.
          \item Case $FV(\meta{e_1}\ \meta{e_2})=FV(\meta{e_1}) \cup FV(\meta{e_2})$.
            \begin{enumerate}
              \item $\meta{x} \in FV(\meta{e_1})$. Since $\meta{\Gamma}\vdash\meta{e_1}\ \meta{e_2}:\meta{\tau}$, according to the typing rule, the only way to get this is
              $$\inferrule{
                \meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}\to\meta{\tau}\and
                \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_1}
              }{\meta{\Gamma}\vdash\meta{e_1}\ \meta{e_2} : \meta{\tau}}$$
              Therefore, $\meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}\to\meta{\tau}$. Since, in this case, $\meta{x}\in FV(\meta{e_1})$, according to the induction hypothesis, there exists a type $\tau^\prime$ such that $\meta{\Gamma}\vdash\meta{x}:\meta{\tau^\prime}$.
              \item $\meta{x} \in FV(\meta{e_2})$. Similar as Case A.
            \end{enumerate}
        \end{enumerate}
        \item Case $FV(\texttt{if}\ \meta{e_1}\ \texttt{then}\ \meta{e_2}\texttt{else}\ \meta{e_3})=FV(\meta{e_1})\cup FV(\meta{e_2})\cup FV(\meta{e_3})$. Similar as Case iii.
        \item Case $FV(\lambda\meta{y}. \meta{e})=FV(\meta{e}) - \set{\meta{y}}$. In this case, $\meta{x}$ is free in $\meta{e}$. Since $\meta{\Gamma}\lbrack \meta{y}\mapsto \meta{\tau_1} \rbrack \vdash\meta{e}:\meta{\tau}$, and note that $\meta{y} \neq \meta{x}$ since $\meta{x}$ is also free in $\lambda\meta{y}. \meta{e}$, according to the induction hypothesis, there exists a $\meta{\tau^\prime}$ such that $\meta{\Gamma}\vdash \meta{x}:\meta{\tau^\prime}$.
    \end{proof}
    This lemma is stronger. Having $\cdot\vdash\meta{e}:\meta{\tau}$ and assuming that $\meta{e}$ is not closed, then there exists a free variable $\meta{x}\in FV(\meta{e})$ such that $\cdot\vdash\meta{x}:\meta{\tau^\prime}$. However, $\cdot$ is an empty envrionment, so the domain of $\cdot$ is $\emptyset$, and no free variable can be assigned a type in this context. This contradicts with the conclusion of the lemma that $\exists \meta{\tau^\prime}, \cdot\vdash\meta{x}:\meta{\tau^\prime}$. So if $\cdot\vdash\meta{e}:\meta{\tau}$, $\meta{e}$ must be closed.

  \end{enumerate}
\item This problem is about the substitution operator $\meta{e_1}[\meta{e}/\meta{x}]$.
  \begin{enumerate}[(a)]
  \item In the definition of substitution, for the $\lambda$ case, there are two
    side conditions, $\meta{y}\ne\meta{x}$ (which we forgot to write in lecture)
    and $\meta{y}\not\in FV(\meta{e})$. For the first side condition, $\meta{y}\ne\meta{x}$,
    explain what can go wrong if we leave it out by giving a concrete example where
    substitution behaves unexpectedly.

    \textbf{If we leave the restriction $\meta{y} \neq \meta{x}$ out, the substitution can change the semantics of the lambda abstraction by substituting a bound variable. For instance: if we have $(\lambda \meta{x}. \meta{x}\ \meta{x})\lbrack \meta{v}/\meta{x}\rbrack$, this would be rewritten to $\lambda \meta{x}. \meta{v}\ \meta{v}$, which changed the semantics of the lambda abstraction.}

  \item Explain what \emph{should} happen if $\meta{y} = \meta{x}$. Why is it ok to \emph{not} handle this case explicitly in the definition of substitution?
    
    \textbf{The body of the lambda abstraction should remain the same after substitution. It is ok to not handle this case since if $\meta{y}=\meta{x}$, the behavior is defined in application}

  \item Now consider the second side condition from the $\lambda$ case, namely $\meta{y}\not\in FV(\meta{e})$.
    Describe a simple condition on $\meta{e}$ that (1) ensures this side condition is always met;
    and (2) is sufficient to cover the cases we encountered in proving type safety.
    In your answer, state your condition clearly, and explain briefly and informally why it satisfies (1) and (2).
  \item Suppose we remove this second side condition. Explain informally why any
    expression that is well typed in the empty context still evaluates the same
    way without this side condition.
    
    \textbf{According to the theorem proved in Question 1, if an expression $\meta{e}$ is well-typed in an empty context, then $\meta{e}$ is closed, hence $FV(\meta{e}) = \emptyset$, and $\forall \meta{y}.\ \meta{y}\not\in \emptyset$, so ignoring the second condition does not affect the way of evaluating the substitution.}

  \item Find a well-typed expression (in a non-empty context!) that steps
    differently with and without this second side condition.  In your answer,
    state your expression and its typing context clearly, and show informally
    the two different executions it has with and without this side condition.

    \textbf{Consider the expression $(\lambda\meta{x}. \texttt{if}\ \meta{x}\ \texttt{then}\ \meta{y}\ \texttt{else}\ \meta{x})\ true$ with the context $\lbrack \meta{y}\mapsto bool \rbrack$, and we are to substitute $\meta{y}$ with $\meta{x}$, i.e. $((\lambda\meta{x}.\ \texttt{if}\ \meta{x}\ \texttt{then}\ \meta{y}\ \texttt{else}\ \meta{x})\lbrack \meta{x} / \meta{y} \rbrack)\ true$. Obviously, $\meta{x}$ is free in current context, and $\meta{x} \neq \meta{y}$ so we can proceed the substitution (ignoring the second condition). After substitution, the expression becomes $(\lambda\meta{x}.\ \texttt{if}\ \meta{x}\ \texttt{then}\ \meta{x}\ \texttt{else}\ \meta{x})\ true$. These two expressions can execute differently: consider having $\meta{y} = false$, the original application yields $false$ but after substitution, the expression evaluates to $true$ instead.}

  \end{enumerate}
\item This problem considers adding pairs to the language. Your job is to add syntax and rules, and to update the proofs.
  \begin{enumerate}[(a)]
  \item Add new syntax.
    \begin{itemize}
    \item For expressions, add $(\meta{e}, \meta{e})$, to construct a pair, and
      $\meta{e}.1$ and $\meta{e}.2$, to project out the components.

      \textbf{extends $\meta{e}$ with}
      $\meta{e} ::= (\meta{e}, \meta{e})\ |\ \meta{e}.1\ |\ \meta{e}.2$

    \item For values, add a new branch to the grammar so that a pair of
      values is considered a value.

      \textbf{Extends $\meta{v}$ with}
      $\meta{v} ::= (\meta{v}, \meta{v})$

    \item For types, make it so the product of two types, written
      $\meta{\tau_1}\times\meta{\tau_2}$ is a type.

      \textbf{Extends $\meta{\tau}$} with $\meta{\tau} ::= \meta{\tau}\times\meta{\tau}$
    \end{itemize}
  \item Add semantics. (4 boring rules and 2 rules ``where stuff happens''.)
    \begin{itemize}
    \item Add rules to $\meta{e}\to\meta{e}$ such that pairs $(\meta{e_1},\meta{e_2})$ get evaluated in left to right order.
      \begin{mathpar}
        \inferrule{
          \meta{e_1} \to \meta{e_1^\prime}
        }{(\meta{e_1}, \meta{e_2}) \to (\meta{e_1^\prime}, \meta{e_2})}\and
        \inferrule{
          \meta{e_2} \to \meta{e_2^\prime}
        }{(\meta{v}, \meta{e_2}) \to (\meta{v}, \meta{e_2^\prime})}
      \end{mathpar}
    \item For $\meta{e}.1$ and $\meta{e}.2$, make sure that $\meta{e}$ gets evaluated to a value before the projection occurs.
      \begin{mathpar}
        \inferrule{
          \meta{e_1} \to \meta{e_1^\prime}
        }{(\meta{e_1}, \meta{e_2}).1 \to (\meta{e_1^\prime}, \meta{e_2}).1}\and
        \inferrule{
          \meta{e_1} \to \meta{e_1^\prime}
        }{(\meta{e_1}, \meta{e_2}).2 \to (\meta{e_1^\prime}, \meta{e_2}).2}
      \end{mathpar}

      \begin{mathpar}
        \inferrule{
          \meta{e_2} \to \meta{e_2^\prime}
        }{(\meta{v}, \meta{e_2}).1 \to (\meta{v}, \meta{e_2^\prime}).1}\and
        \inferrule{
          \meta{e_2} \to \meta{e_2^\prime}
        }{(\meta{v}, \meta{e_2}).2 \to (\meta{v}, \meta{e_2^\prime}).2}
      \end{mathpar}

      \begin{mathpar}
        \inferrule{ }{(\meta{v_1}, \meta{v_2}).1 \to \meta{v_1}}\and
        \inferrule{ }{(\meta{v_1}, \meta{v_2}).2 \to \meta{v_2}}
      \end{mathpar}
    \end{itemize}
  \item Add typing rules. Add one rule per new expression AST node.
    \begin{mathpar}
      \inferrule{
        \meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}\and
        \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_2}
      }{\meta{\Gamma}\vdash(\meta{e_1}, \meta{e_2}) : \meta{\tau_1}\times\meta{\tau_2}}\and
      \inferrule{
        \meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}
      }{\meta{\Gamma}\vdash\meta{e}.1 :\meta{\tau_1}}\and
      \inferrule{
        \meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}
      }{\meta{\Gamma}\vdash\meta{e}.2 :\meta{\tau_2}}
    \end{mathpar}
  \item Extend the proof of type safety, as follows:
    \begin{itemize}
    \item Add cases to the proof of the progress lemma from lecture for each new
      typing rule you added. No need to repeat the cases we covered in lecture,
      just handle your new rules. If you need any lemmas, clearly state them,
      and describe in one sentence how you \emph{would} prove them (by induction
      or some other way? induction on what?), but no need to prove your lemmas.
      \begin{enumerate}
        \item Case \inferrule{
          \meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}\and
          \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_2}
        }{\meta{\Gamma}\vdash(\meta{e_1}, \meta{e_2}) : \meta{\tau_1}\times\meta{\tau_2}}. According to the induction hypothesis, $\meta{e_1}$ is not a stuck, therefore:
          \begin{itemize}
            \item $\meta{e_1}$ is a value. Then according to the induction hypothesis, $\meta{e_2}$ is not a stuck. If $\meta{e_2}$ is a value., then $(\meta{e_1}, \meta{e_2})$ is value, and it is not a stuck; if $\meta{e_2} \to \meta{e_2^\prime}$, then the expression can take this step: $(\meta{e_1}, \meta{e_2}) \to (\meta{e_1}, \meta{e_2}^\prime)$. Thus it is not a stuck in both cases.
            \item $\meta{e_1}$ can step to $\meta{e_1^\prime}$. Then directly, $(\meta{e_1}, \meta{e_2})$ can step to $(\meta{e_1^\prime}, \meta{e_2})$, thus it is not a stuck.
          \end{itemize}
        \item Case $\inferrule{
          \meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}
        }{\meta{\Gamma}\vdash\meta{e}.1 :\meta{\tau_1}}$. Since $\meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}$, $\meta{e}=(\meta{e_1}, \meta{e_2})$ for some $\meta{e_1}$ and $\meta{e_2}$, and $\meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}$ and $\meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_2}$. According to the induction hypothesis, $\meta{e}$ is not a stuck, therefore:
          \begin{itemize}
            \item $\meta{e}$ is a value. Then $\meta{e}=(\meta{v_1}, \meta{v_2})$, and $\meta{e}.1=\meta{v_1}$, which is a value, and thus $\meta{e}.1$ is not a stuck.
            \item $\meta{e}$ can step. Then by case analysis on $\meta{e}\to \meta{e^\prime}$
              \begin{enumerate}
                \item $\inferrule{
                  \meta{e_1} \to \meta{e_1^\prime}
                }{(\meta{e_1}, \meta{e_2}) \to (\meta{e_1^\prime}, \meta{e_2})}$. According to the evaluation rule, $\inferrule{
                  \meta{e_1} \to \meta{e_1^\prime}
                }{(\meta{e_1}, \meta{e_2}).1 \to (\meta{e_1^\prime}, \meta{e_2}).1}$, therefore, $\meta{e}$ is not a stuck.
                \item $\inferrule{
                  \meta{e_2} \to \meta{e_2^\prime}
                }{(\meta{v}, \meta{e_2}) \to (\meta{v}, \meta{e_2^\prime})}$. Similar as Case A.
              \end{enumerate}
          \end{itemize}
        \item Case $\inferrule{
          \meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}
        }{\meta{\Gamma}\vdash\meta{e}.2 :\meta{\tau_2}}$. Similar as Case ii.
      \end{enumerate}
    \item Add cases to the proof of the preservation lemma from lecture. Same
      directions as above about repeated cases and lemmas.
      \begin{enumerate}
        \item Case \inferrule{
          \meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}\and
          \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_2}
        }{\meta{\Gamma}\vdash(\meta{e_1}, \meta{e_2}) : \meta{\tau_1}\times\meta{\tau_2}}. According to the induction hypothesis, if $\meta{e_1} \to \meta{e_1^\prime}$, then $\meta{\Gamma}\vdash\meta{e_1^\prime} : \meta{\tau_1}$, similar for $\meta{e_2^\prime}$. Therefore, by case analysis on $\meta{e} \to \meta{e^\prime}$:
          \begin{itemize}
            \item $\inferrule{
              \meta{e_1}\to\meta{e_1^\prime}
            }{(\meta{e_1}, \meta{e_2})\to(\meta{e_1^\prime}, \meta{e_2})}$. In this case, according to the induction hypothesis, $$\inferrule{
                          \meta{\Gamma}\vdash\meta{e_1^\prime}:\meta{\tau_1}\and
                          \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_2}}{\meta{\Gamma}\vdash(\meta{e_1^\prime}, \meta{e_2}):\meta{\tau_1}\times\meta{\tau_2}}$$
            \item $\inferrule{
              \meta{e_2}\to\meta{e_2^\prime}
            }{(\meta{v}, \meta{e_2})\to(\meta{v},\meta{e_2^\prime})}$. Similar as case above.
          \end{itemize}
        \item Case $\inferrule{
          \meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}
        }{\meta{\Gamma}\vdash\meta{e}.1 :\meta{\tau_1}}$. By case analysis on $\meta{e}$:
          \begin{itemize}
            \item $\meta{e}$ is a value. Then $\meta{e}=(\meta{v_1}, \meta{v_2})$. Since $\meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}$, $\meta{\Gamma}\vdash\meta{v_1}:\meta{\tau_1}$. Therefore, in this case $\meta{e}.1=\meta{v_1}$, and thus $\meta{\Gamma}\meta{e}.1:\meta{\tau_1}$.
            \item $\meta{e}$ can step. Then there are two ways to step,
              \begin{enumerate}
                \item $\inferrule{
                  \meta{e_1} \to \meta{e_1^\prime}
                }{(\meta{e_1}, \meta{e_2}) \to (\meta{e_1^\prime}, \meta{e_2})}$. Since $\meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}$, according to the induction hypothesis, $\meta{\Gamma}\meta{e_1^\prime}:\meta{\tau_1}$. Therefore, $\inferrule{
                  \meta{\Gamma}\vdash\meta{e_1^\prime}:\meta{\tau_1}\and
                  \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_2}
                }{\meta{\Gamma}\vdash(\meta{e_1^\prime}, \meta{e_2}):\meta{\tau_1}\times\meta{\tau_2}}$. According to the typing rule, $\meta{\Gamma}\vdash(\meta{e_1^\prime}, \meta{e_2}).1:\meta{\tau_1}$.
                \item $\inferrule{
                \meta{e_2} \to \meta{e_2^\prime}
              }{(\meta{v}, \meta{e_2}) \to (\meta{v}, \meta{e_2^\prime})}$. Similar as case A.
              \end{enumerate}
          \end{itemize}
          \item Case $\inferrule{
            \meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}
          }{\meta{\Gamma}\vdash\meta{e}.2 :\meta{\tau_2}}$. Similar as Case ii.
      \end{enumerate}
    \end{itemize}
  \end{enumerate}
\end{enumerate}

\section*{Problems from after Lecture on Friday 4/17}

\begin{enumerate}[resume*]
\item Consider the type $(bool\to bool)\to (bool\to bool)$.
  \begin{enumerate}[(a)]
  \item Give an example of an expression with this type. (Try to make it at
    least slightly interesting, but not so interesting that the rest of this
    problem is tedious.)
    $$\lambda f.\ \lambda x. f\ x$$

  \item Draw a typing derivation showing that your expression actually does have this type.
    $$\inferrule{
      [\meta{f} \mapsto (bool \to bool)]\vdash \inferrule{
        [\meta{f}\mapsto (bool \to bool);\meta{x} \mapsto bool]\vdash \meta{f}\ \meta{x} : bool 
      }{[\meta{f}\mapsto (bool \to bool)]\vdash \lambda x. \meta{f}\ \meta{x} : (bool \to bool)}
    }{\cdot \vdash \lambda f. \lambda x.\ \meta{f}\ \meta{x} : (bool \to bool) \to (bool \to bool)}$$
  \item Translate the meaning of $T(R_{(bool\to bool)\to (bool\to bool)})$ from
    its definition into English. For example, you might start with ``The set of
    expressions that can step to...''.
    
    \textbf{The set of expressions that step to a value which is in the set of reachable value of type $(bool \to bool)\to (bool \to bool)$}

  \item Show directly from the definition of $T$ and $R_{\meta{\tau}}$ that your
    expression is in $T(R_{(bool\to bool)\to (bool\to bool)})$.

    According to the definition of $R_{\meta{\tau}}$, $R_{(bool \to bool)\to (bool \to bool)}$ is
    $$\set{\lambda \meta{x}.\ \meta{e} | \forall \meta{v} \in R_{bool \to bool},\meta{e}[\meta{v}/\meta{x}] \in T(R_{bool \to bool})}$$

    and $$R_{bool \to bool}=\set{\lambda \meta{y}.\ \meta{e_y}| \forall \meta{v} \in R_{bool}, \meta{e_y}[\meta{v}/\meta{y}] \in T(R_{bool})}$$

    Since $\lambda \meta{f}.\lambda \meta{x}.\ \meta{f}\ \meta{x} \to^* \lambda \meta{f}.\lambda \meta{x}.\ \meta{f}\ \meta{x}$, we can check whether $\lambda \meta{f}.\lambda \meta{x}.\ \meta{f}\ \meta{x} \in R_{(bool \to bool)\to (bool \to bool)}$. That is, whether $\forall \meta{v} \in R_{bool \to bool}, (\lambda \meta{x}.\ \meta{f}\ \meta{x})[\meta{v}/\meta{f}] \in T(R_{bool \to bool})$. Similarly, after substitution, since $\lambda \meta{x}.\ \meta{v}\ \meta{x} \to^* \lambda \meta{x}.\ \meta{f}\ \meta{x}$, we can check whether $\lambda \meta{x}.\ \meta{f}\ \meta{x}$ is in $R_{bool \to bool}$, which is whether $\forall \meta{v^\prime} \in R_{bool}, (\meta{v}\ \meta{x})[\meta{v^\prime}/\meta{x}] \in T(R_{bool})$. After substitution, we know that $\meta{v} \in R_{bool \to bool}$ and $\meta{v^\prime} \in \set{\texttt{True}, \texttt{False}}$; therefore $\meta{v}$ must be in the form of $\lambda \meta{y}.\ \meta{e^\prime}$ and $\forall \meta{b}\in bool, \meta{e^\prime}[\meta{b}/\meta{y}]\in T(R_{bool})$. According to the definition of application $(\lambda \meta{y}.\ \meta{e^\prime}) \meta{v^\prime} \to \meta{e^\prime}[\meta{v^\prime}/\meta{y}]$, since $\meta{v^\prime} \in R_{bool}$, $\meta{e^\prime}[\meta{v^\prime}/\meta{y}] \in T(R_{bool})$. Thus we can conclude that $\forall \meta{v^\prime} \in R_{bool}, (\meta{v}\ \meta{x})[\meta{v^\prime}/\meta{x}] \in T(R_{bool})$, subsequently, $\forall \meta{v}\in R_{bool \to bool}, (\lambda\meta{x}.\ \meta{f}\ \meta{x})[\meta{v}/\meta{f}] \in T(R_{bool \to bool})$. Therefore the expression $\lambda \meta{f}.\lambda \meta{x}.\ \meta{f}\ \meta{x} \in T(R_{(bool \to bool) \to (bool \to bool)})$.

  \end{enumerate}
\item Practice with multisubstitutions.
  \begin{enumerate}[(a)]
  \item In lecture, we said a multisubstitution was a map from variables to
    values.  Explain why nothing goes wrong if we actually allow a variable to
    map to any expression, not just values.

    \textbf{It should not go wrong, since this is like changing call-by-value to call-by-name evaluation.}

  \item When proving type safety for STLC with booleans, we used a substitution
    lemma that said, essentially, ``substitution preserves typing''.
    Prove (by induction on a thing of your choice) the following claim about multisubstitutions.
    \begin{quote}
      For all $\meta{\Gamma_1}$, $\meta{\Gamma_2}$, $\meta{e}$, $\meta{\tau}$, and $\meta{\gamma}$,\\
      if \\
      \phantom{$\quad$} $\meta{\Gamma_1}\vdash\meta{e}:\meta{\tau}$, and  \\
      \phantom{$\quad$} $\dom{\meta{\Gamma_1}}\subseteq\dom{\meta{\gamma}}$, and \\
      \phantom{$\quad$} for all $\meta{x}\in\dom\meta{\Gamma_1}$, we have $\meta{\Gamma_2}\vdash\meta{\gamma}(\meta{x}):\meta{\Gamma_1}(\meta{x})$,\\
      then $\meta{\Gamma_2}\vdash\meta{e}[\meta{\gamma}] : \meta{\tau}$.
    \end{quote}
    (Hint: The proof is pretty straightforward. The hard part is wrapping your head around what this claim is saying...)
    \begin{proof}
      By induction on the type derivation $\meta{\Gamma_1}\vdash \meta{e}:\meta{\tau}$.
      \begin{itemize}
        \item $\inferrule{ }{\meta{\Gamma_1}\vdash \meta{b}:bool}$. Since $\meta{e}$ in this case is a boolean literal, $\meta{e}[\meta{\gamma}]$ does not change the value of $e$, thus $\inferrule{ }{\meta{\Gamma_2}\vdash \meta{v}:bool}$ also holds.
        \item $\inferrule{\meta{\Gamma_1}\vdash \meta{e_1}:\meta{\tau_1}\to \meta{\tau_2}\and \meta{\Gamma_1}\vdash \meta{e_2}:\meta{\tau_1}}{\meta{\Gamma_1}\vdash \meta{e_1}\ \meta{e_2} : \meta{\tau_2}}$. According to the induction hypothesis, $\meta{\Gamma_2}\vdash \meta{e_1}[\meta{\gamma}]:\meta{\tau_1}\to \meta{\tau_2}$ and $\meta{\Gamma_2}\vdash\meta{e_2}[\meta{\gamma}]:\meta{\tau_1}$. Thus $\meta{\Gamma_2}\vdash (\meta{e_1}[\meta{\gamma}]\ \meta{e_2}[\meta{\gamma}]):\meta{\tau_2}$. 
        
        According to the definition of multisubstitution, $\meta{\Gamma_2}\vdash (\meta{e_1}\ \meta{e_2})[\meta{\gamma}]:\meta{\tau_2}$.
        \item $\inferrule{
          \meta{\Gamma_1}\vdash \meta{e_1}:bool\and
          \meta{\Gamma_1}\vdash \meta{e_2}:\meta{\tau}\and
          \meta{\Gamma_1}\vdash \meta{e_3}:\meta{\tau}
        }{\meta{\Gamma_1}\vdash (\progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3}) : \meta{\tau}}$. Similar as the provious case.
        \item $\inferrule{
          \meta{x} \in \dom{\meta{\Gamma_1}}\and
          \meta{\Gamma_1}(\meta{x}) = \meta{\tau}
        }{\meta{\Gamma_1}\vdash\meta{}:\meta{\tau}}$. Since $\meta{\Gamma_1}\vdash(\meta{x}) = \meta{\tau}$. Therefore, according to our premises, $\meta{\Gamma_2}\vdash \meta{\gamma}(\meta{x}) : \meta{\tau}$.
        \item $\inferrule{
          \meta{\Gamma_1}[\meta{x}\mapsto \meta{\tau_1}]\vdash \meta{e}:\meta{\tau_2}
        }{\meta{\Gamma_1}\vdash \lambda \meta{x}.\ \meta{e} : \meta{\tau_1}\to\meta{\tau_2}}$. Since $\meta{\Gamma_2}\vdash \meta{\gamma}(\meta{x}) : \meta{\Gamma_1}(\meta{x})$ for all $\meta{x}\in \dom{\meta{\Gamma_1}}$ and $\meta{\Gamma_1}[\meta{x} \mapsto \meta{\tau_1}]\vdash \meta{e}:\meta{\tau_2}$, $\meta{\Gamma_2}[\meta{x} \mapsto \meta{\tau_1}]\vdash \meta{e}[\meta{\gamma} - \meta{x}] : \meta{\tau_2}$. Therefore, $\meta{\Gamma_2}\vdash \lambda\meta{x}.\ \meta{e}[\meta{\gamma} - \meta{x}] : \meta{\tau_1}\to \meta{\tau_2}$. According to the definition of multisubstitution, $\meta{\Gamma_2}\vdash (\lambda. \meta{x}. \meta{e})[\meta{\gamma}] : \meta{\tau_1}\to\meta{\tau_2}$.
      \end{itemize}
    \end{proof}

  \end{enumerate}

\item Practice with logical relations proofs. We refer to the statement
  ``If $\meta{\Gamma}\vdash\meta{e}:\meta{\tau}$, then $\meta{\Gamma}\vDash\meta{e}:\meta{\tau}$.''
  as the ``fundamental theorem of the logical relation''.
  \begin{enumerate}[(a)]
  \item Write out the case for $\lambda$ in the proof of the fundamental theorem
    in full detail. (Shouldn't be more than a short paragraph.)

    \begin{itemize}
      \item Case $\inferrule{
        \meta{\Gamma}[\meta{x}\mapsto \meta{\tau_1}]\vdash \meta{e} :\meta{\tau_2}
      }{\meta{\Gamma}\vdash \lambda \meta{x}.\ \meta{e} : \meta{\tau_1}\to \meta{\tau_2}}$. According to the induction hypothesis, $\exists \meta{v}, \meta{e}[\meta{\gamma}] \to^* \meta{v}, \meta{v} \in R_{\tau_2}$. Specifically, $\meta{\gamma}$ is in the form of $\meta{\gamma^\prime}[\meta{x} \mapsto \meta{v}]$ where $\meta{v} \in R_{(\meta{\Gamma}[\meta{x}\mapsto \meta{\tau_1}])(\meta{x})}$, which is $\meta{v} \in R_\meta{\tau_1}$. Therefore, $\forall \meta{v} \in R_{\meta{\tau_1}}, (\meta{e}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}] \in T(R_\meta{\tau_2})$. Then, according to the definition of $R$, $\lambda \meta{x}.\ \meta{e}[\meta{\gamma^\prime}] \in R_{\meta{\tau_1}\to\meta{\tau_2}}$. Since $\dom{\meta{\gamma^\prime}[\meta{x} \mapsto \meta{v}]}=\dom{\meta{\Gamma}[\meta{x}\mapsto \meta{\tau_1}]}$, $\dom{\meta{\gamma^\prime}}=\dom{\meta{\Gamma}}$. Subsequently, $(\lambda \meta{x}. \meta{e})[\meta{\gamma^\prime}] \in T(R_{\meta{\tau_1}\to\meta{\tau_2}})$. 
    \end{itemize}

  \item What lemma relating multisubstitutions and (single-)substitutions do you
    need for the $\lambda$ case of the proof? State it formally and prove it.

    \textbf{For all $\meta{\gamma}$, $\meta{\gamma^\prime}$, $\meta{e}$, $\meta{\tau}$, $\meta{v}$ and $\meta{x}$, if $\meta{\gamma}=\meta{\gamma^\prime}[\meta{x}\mapsto \meta{v}]$, then $\meta{e}[\meta{\gamma}]=(\meta{e}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}]$}
    \begin{proof}
      By induction on the expression $\meta{e}$.
      \begin{itemize}
        \item Case $\meta{b}$. $\meta{e}$ in this case is a literal. Then substitution does not change anything, so $\meta{e}[\meta{\gamma}]=(\meta{e}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}]$ holds trivially.
        \item Case $\lambda \meta{x}.\ \meta{e}$. According to the induction hypothesis, $\meta{e}[\meta{\gamma}]=(\meta{e}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}]$. 
          \begin{align*}
            (\lambda \meta{x}.\ \meta{e})[\meta{\gamma^\prime}] &= \lambda \meta{x}.\ \meta{e}[\meta{\gamma^\prime}] \\
            &= \lambda \meta{x}. (\meta{e}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}] & \text{Induction Hypothesis}\\
            &= (\lambda \meta{x}.\meta{e}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}] \\
            &= ((\lambda \meta{x}.\ \meta{e})[\meta{\gamma^\prime}])[\meta{v}/\meta{x}]
          \end{align*}
        \item Case $\meta{e_1}\ \meta{e_2}$.
          \begin{align*}
            (\meta{e_1}\ \meta{e_2})[\meta{\meta{\gamma}}] &= (\meta{e_1}[\meta{\gamma}]\ \meta{e_2}[\meta{\gamma}]) \\
            &= (\meta{e_1}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}]\ (\meta{e_2}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}] & \text{Induction Hypothesis} \\
            &= (\meta{e_1}[\meta{\gamma^\prime}]\ \meta{e_2}[\meta{\gamma^\prime}])[\meta{v}/\meta{x}] \\
            &= ((\meta{e_1}\ \meta{e_2})[\meta{\gamma^\prime}])[\meta{v}/\meta{x}]
          \end{align*}
        \item Case. If-then-else. Similar as the previous case.
      \end{itemize}
    \end{proof}

  \item Extend the definition of $R_{\meta{\tau}}$ to the pair type you introduced in your solution to Problem~\ref{prob:pairs}.

    $$R_{\tau_1 \times \tau_2}=\set{(\meta{e_1}, \meta{e_2}) | \meta{e_1} \in T(R_{\meta{\tau_1}}), \meta{e_2} \in T(R_{\meta{\tau_2}})}$$

  \item Extend the definition of $\meta{e}[\meta{\gamma}]$ to support the new
    kinds of expressions you introduced in your solution to
    Problem~\ref{prob:pairs}.

    \begin{align*}
      (\meta{e_1}, \meta{e_2})[\meta{\gamma}] &= (\meta{e_1}[\meta{\gamma}], \meta{e_2}[\meta{\gamma}])\\
      (\meta{e_1}, \meta{e_2}).1[\meta{\gamma}] &= (\meta{e_1}[\meta{\gamma}], \meta{e_2}[\meta{\gamma}]).1\\
      (\meta{e_1}, \meta{e_2}).2[\meta{\gamma}] &= (\meta{e_1}[\meta{\gamma}], \meta{e_2}[\meta{\gamma}]).2
    \end{align*}

  \item For each new expression you introduced in your solution to
    Problem~\ref{prob:pairs}, add the corresponding case to the proof of the fundamental theorem for the logical relation.
    % \textbf{Lemma 6-1. For all well-typed expressions $\meta{e_1}$, $\meta{e_2}$ and values $\meta{v_1}$, $\meta{v_2}$, if $(\meta{e_1}, \meta{e_2}) \to^* (\meta{v_1}, \meta{v_2})$, then $$}
    \begin{itemize}
      \item $\inferrule{
        \meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}\and
        \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_2}
      }{\meta{\Gamma}\vdash(\meta{e_1}, \meta{e_2}) : \meta{\tau_1}\times\meta{\tau_2}}$. According to the induction hypothesis, $\exists \meta{v_1} \in R_{\meta{\tau_1}}, \meta{e_1}[\meta{\gamma}] \to^* \meta{v_1}$ and $\exists \meta{v_2} \in R_{\meta{\tau_2}}, \meta{e_2}[\meta{\gamma}] \to^* \meta{v_2}$. Thus $\exists (\meta{v_1}, \meta{v_2 }), \meta{v_1} \in R_{\meta{\tau_1}}, \meta{v_2} \in R_{\meta{\tau_2}}, (\meta{e_1}[\meta{\gamma}], \meta{e_2}[\meta{\gamma}]) \to^* (\meta{v_1}, \meta{v_2})$. According to the definition of multisubstitution, subsequently we can get $(\meta{e_1}, \meta{e_2})[\meta{\gamma}] \to^* (\meta{v_1}, \meta{v_2})$, thus $(\meta{e_1}, \meta{e_2})[\meta{\gamma}] \in T(R_{\meta{\tau_1} \times \meta{\tau_2}})$.
      \item $\inferrule{
        \meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}
      }{\meta{\Gamma}\vdash\meta{e}.1 :\meta{\tau_1}}$. Let $\meta{e} = (\meta{e_1}, \meta{e_2})$. According to the inudction hypothesis, $\exists (\meta{v_1}, \meta{v_2}) \in R_{\meta{\tau_1} \times \meta{\tau_2}}, (\meta{e_1}, \meta{e_2})[\meta{\gamma}] \to^* (\meta{v_1}, \meta{v_2})$. Therefore, $(\meta{e_1}[\meta{\gamma}], \meta{e_1}[\meta{\gamma}]).1 \to^* (\meta{v_1}, \meta{v_2}).1$. Since projection occures only when $\meta{e}$ is a value, which is $(\meta{v_1}, \meta{v_2})$, $\meta{e}.1 = (\meta{v_1}, \meta{v_2}).1 = \meta{v_1}$. Since $\meta{v_1} \in R_{\meta{\tau_1}}$, thus $\meta{e}.1[\meta{\gamma}] \in T(R_{\meta{\tau_1}\times \meta{\tau_2}})$.
      \item $\inferrule{
        \meta{\Gamma}\vdash\meta{e}:\meta{\tau_1}\times\meta{\tau_2}
      }{\meta{\Gamma}\vdash\meta{e}.2 :\meta{\tau_2}}$. Similar as the previous case.
    \end{itemize}
  \end{enumerate}
\end{enumerate}


\clearpage
  \noindent\stlc{} with booleans
  \[
    \begin{array}{rcl}
      \meta{e} & ::= & \meta{x} \mid \lambda \meta{x}.\,\meta{e} \mid \meta{e}\ \meta{e}\mid \meta{b} \mid \progif\ \meta{e}\ \progthen\ \meta{e}\ \progelse\ \meta{e}\\
      \meta{v} & ::= & \meta{b} \mid \lambda \meta{x}.\,\meta{e}\\
      \meta{\tau} & ::= & bool \mid \meta{\tau} \to \meta{\tau}\\
      \meta{\Gamma} & \in & Var \rightharpoonup Type
    \end{array}
  \]
  \boxed{\meta{e} \to \meta{e}}
  \begin{mathpar}
    \inferrule{ }{(\lambda\meta{x}.\,\meta{e})\ \meta{v}\to \meta{e}[\meta{v}/\meta{x}]}
    \and
    \inferrule{\meta{e_1}\to\meta{e_1'}}{\meta{e_1}\ \meta{e_2} \to\meta{e_1'}\ \meta{e_2}}
    \and
    \inferrule{\meta{e_2}\to\meta{e_2'}}{\meta{v}\ \meta{e_2} \to\meta{v}\ \meta{e_2'}}\\
    \and
    \inferrule{\meta{e_1}\to\meta{e_1'}}{\progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3} \to \progif\ \meta{e_1'}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3}}\\
    \and
    \inferrule{ }{\progif\ \progtrue\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3} \to \meta{e_2}}
    \and
    \inferrule{ }{\progif\ \progfalse\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3} \to \meta{e_3}}
  \end{mathpar}
  Note that we use $\to$ for both the small-step semantics and for function types.
  You can always tell which one we mean by seeing if the arguments are types or expressions.

  \vspace{3mm}

  \noindent\boxed{\meta{e_1}[\meta{e}/\meta{x}]}
  \[
    \begin{array}{rcll}
      \meta{x}[\meta{e}/\meta{x}] & = & \meta{e} &\\
      \meta{y}[\meta{e}/\meta{x}] & = & \meta{y} & (\meta{y} \ne \meta{x})\\
      (\lambda\meta{y}.\, \meta{e_1})[\meta{e}/\meta{x}] & = & \lambda\meta{y}.\, \meta{e_1}[\meta{e}/\meta{x}] & (\meta{y} \ne \meta{x}\ \text{and}\ \meta{y} \not\in FV(\meta{e}))\\
      (\meta{e_1}\ \meta{e_2})[\meta{e}/\meta{x}] & = & \meta{e_1}[\meta{e}/\meta{x}]\ \meta{e_2}[\meta{e}/\meta{x}]&\\
      \meta{b}[\meta{e}/\meta{x}] & = & \meta{b} &\\
      (\progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3})[\meta{e}/\meta{x}] & = & \progif\ \meta{e_1}[\meta{e}/\meta{x}] &\\
      & & \progthen\ \meta{e_2}[\meta{e}/\meta{x}] & \\
      & & \progelse\ \meta{e_3}[\meta{e}/\meta{x}] &
    \end{array}
  \]
  \boxed{FV(\meta{e})}
  \[
    \begin{array}{rcl}
      FV(\meta{x}) & = & \set{\meta{x}} \\
      FV(\lambda\meta{x}.\, \meta{e}) & = & FV(\meta{e}) - \set{x}\\
      FV(\meta{e_1}\ \meta{e_2}) & = & FV(\meta{e_1})\cup FV(\meta{e_2})\\
      FV(\meta{b}) & = & \emptyset\\
      FV(\progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3}) & = & FV(\meta{e_1}) \cup FV(\meta{e_2}) \cup FV(\meta{e_3})\\
    \end{array}
  \]
  We say that $\meta{e}$ is \emph{closed} if $FV(\meta{e}) = \emptyset$.

  \vspace{3mm}

  \noindent\boxed{\meta{\Gamma} \vdash \meta{e} : \meta{\tau}}
  \begin{mathpar}
    \inferrule{ }{\meta{\Gamma} \vdash \meta{b} : bool}
    \and
    \inferrule{\meta{\Gamma} \vdash \meta{e_1} : bool \and \meta{\Gamma} \vdash \meta{e_2} : \meta{\tau}\and \meta{\Gamma} \vdash\meta{e_3} : \meta{\tau} }
              {\meta{\Gamma} \vdash \progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3} : \meta{\tau}}
    \and
    \inferrule{\meta{x} \in \dom{\meta{\Gamma}} \and \meta{\Gamma}(\meta{x}) = \meta{\tau}}{\meta{\Gamma} \vdash \meta{x} : \meta{\tau}}\\
    \and
    \inferrule{\meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}\to\meta{\tau_2} \and \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_1}}
              {\meta{\Gamma}\vdash\meta{e_1}\ \meta{e_2}:\meta{\tau_2}}
    \and
    \inferrule{\meta{\Gamma}[\meta{x}\mapsto\meta{\tau_1}]\vdash\meta{e}:\meta{\tau_2}}
              {\meta{\Gamma}\vdash\lambda\meta{x}.\,\meta{e}:\meta{\tau_1}\to\meta{\tau_2}}
  \end{mathpar}

  \clearpage
  \noindent Definitions for a logical relation to prove termination of \stlc{} with booleans.

  \vspace{3mm}

  \noindent\boxed{T(P)}

  \[
    T(P) = \set{\meta{e} | \exists\meta{v}.\, \meta{e}\to^*\meta{v} \wedge \meta{v} \in P}
  \]

  \noindent\boxed{R_{\meta{\tau}}}
  \[
    \begin{array}{rcl}
      R_{bool} & = & \set{\progtrue,\progfalse}\\
      R_{\meta{\tau_1}\to\meta{\tau_2}} & = & \set{\lambda\meta{x}.\,\meta{e} | \forall \meta{v}\in R_{\meta{\tau_1}}.\, \meta{e}[\meta{v}/\meta{x}] \in T(R_{\meta{\tau_2}})}
    \end{array}
  \]

  \vspace{3mm}  

  \[
    \begin{array}{rcl}
      \meta{\gamma} & \in & Var \rightharpoonup Expr
    \end{array}
  \]

  \vspace{3mm}

  \noindent\boxed{\meta{e}[\meta{\gamma}]}
  \[
    \begin{array}{rcll}
      \meta{x}[\meta{\gamma}] & = & \meta{\gamma}(\meta{x}) &\text{if $\meta{x}\in\dom{\meta{\gamma}}$}\\
      \meta{x}[\meta{\gamma}] & = & \meta{x} &\text{if $\meta{x}\not\in\dom{\meta{\gamma}}$}\\
      \meta{b}[\meta{\gamma}] & = & \meta{b} &\\
      (\lambda\meta{x}.\, \meta{e})[\meta{\gamma}] & = & \lambda\meta{x}.\, \meta{e}[\meta{\gamma} - \meta{x}] & (\meta{x} \not\in FV(\meta{\gamma}(\meta{y}))\text{ for any }\meta{y}\in\dom{\meta{\gamma}})\\
      (\meta{e_1}\ \meta{e_2})[\meta{\gamma}] & = & \meta{e_1}[\meta{\gamma}]\ \meta{e_2}[\meta{\gamma}]&\\

      (\progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3})[\meta{\gamma}] & = & \progif\ \meta{e_1}[\meta{\gamma}]\ \progthen\ \meta{e_2}[\meta{\gamma}]\\
      & & \progelse\ \meta{e_3}[\meta{\gamma}] &
    \end{array}
  \]

  \noindent\boxed{\meta{\Gamma}\vdash\meta{\gamma}}
  \[
    \meta{\Gamma}\vdash\meta{\gamma} \quad\iff\quad \forall\meta{x}\in\dom{\meta{\Gamma}}.\ \ \meta{x} \in\dom{\meta{\gamma}}\ \wedge\ \meta{\gamma}(\meta{x}) \in R_{\meta{\Gamma}(\meta{x})}
  \]

  \noindent\boxed{\meta{\Gamma}\vDash\meta{e} : \meta{\tau}}
  \[
    \meta{\Gamma}\vDash\meta{e} : \meta{\tau} \quad\iff\quad \forall\meta{\gamma}.\ \meta{\Gamma}\vdash\meta{\gamma}\Rightarrow \meta{e}[\meta{\gamma}] \in T(R_{\meta{\tau}})
  \]
  
  \vspace{3mm}
  \noindent\textbf{Fundamental theorem of the logical relation:}
  If $\meta{\Gamma}\vdash\meta{e}:\meta{\tau}$, then $\meta{\Gamma}\vDash\meta{e}:\meta{\tau}$.
  \begin{proof}[Proof (in class, quickly).]
    By induction on the derivation that $\meta{\Gamma}\vdash\meta{e}:\meta{\tau}$.
  \end{proof}

\clearpage
  \noindent\stlc{} with booleans
  \[
    \begin{array}{rcl}
      \meta{e} & ::= & \meta{x} \mid \lambda \meta{x}.\,\meta{e} \mid \meta{e}\ \meta{e}\mid \meta{b} \mid \progif\ \meta{e}\ \progthen\ \meta{e}\ \progelse\ \meta{e}\\
      \meta{v} & ::= & \meta{b} \mid \lambda \meta{x}.\,\meta{e}\\
      \meta{\tau} & ::= & bool \mid \meta{\tau} \to \meta{\tau}\\
      \meta{\Gamma} & \in & Var \rightharpoonup Type
    \end{array}
  \]
  \boxed{\meta{e} \to \meta{e}}
  \begin{mathpar}
    \inferrule{ }{(\lambda\meta{x}.\,\meta{e})\ \meta{v}\to \meta{e}[\meta{v}/\meta{x}]}
    \and
    \inferrule{\meta{e_1}\to\meta{e_1'}}{\meta{e_1}\ \meta{e_2} \to\meta{e_1'}\ \meta{e_2}}
    \and
    \inferrule{\meta{e_2}\to\meta{e_2'}}{\meta{v}\ \meta{e_2} \to\meta{v}\ \meta{e_2'}}\\
    \and
    \inferrule{\meta{e_1}\to\meta{e_1'}}{\progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3} \to \progif\ \meta{e_1'}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3}}\\
    \and
    \inferrule{ }{\progif\ \progtrue\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3} \to \meta{e_2}}
    \and
    \inferrule{ }{\progif\ \progfalse\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3} \to \meta{e_3}}
  \end{mathpar}
  Note that we use $\to$ for both the small-step semantics and for function types.
  You can always tell which one we mean by seeing if the arguments are types or expressions.

  \vspace{3mm}

  \noindent\boxed{\meta{e_1}[\meta{e}/\meta{x}]}
  \[
    \begin{array}{rcll}
      \meta{x}[\meta{e}/\meta{x}] & = & \meta{e} &\\
      \meta{y}[\meta{e}/\meta{x}] & = & \meta{y} & (\meta{y} \ne \meta{x})\\
      (\lambda\meta{y}.\, \meta{e_1})[\meta{e}/\meta{x}] & = & \lambda\meta{y}.\, \meta{e_1}[\meta{e}/\meta{x}] & (\meta{y} \ne \meta{x}\ \text{and}\ \meta{y} \not\in FV(\meta{e}))\\
      (\meta{e_1}\ \meta{e_2})[\meta{e}/\meta{x}] & = & \meta{e_1}[\meta{e}/\meta{x}]\ \meta{e_2}[\meta{e}/\meta{x}]&\\
      \meta{b}[\meta{e}/\meta{x}] & = & \meta{b} &\\
      (\progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3})[\meta{e}/\meta{x}] & = & \progif\ \meta{e_1}[\meta{e}/\meta{x}] &\\
      & & \progthen\ \meta{e_2}[\meta{e}/\meta{x}] & \\
      & & \progelse\ \meta{e_3}[\meta{e}/\meta{x}] &
    \end{array}
  \]
  \boxed{FV(\meta{e})}
  \[
    \begin{array}{rcl}
      FV(\meta{x}) & = & \set{\meta{x}} \\
      FV(\lambda\meta{x}.\, \meta{e}) & = & FV(\meta{e}) - \set{x}\\
      FV(\meta{e_1}\ \meta{e_2}) & = & FV(\meta{e_1})\cup FV(\meta{e_2})\\
      FV(\meta{b}) & = & \emptyset\\
      FV(\progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3}) & = & FV(\meta{e_1}) \cup FV(\meta{e_2}) \cup FV(\meta{e_3})\\
    \end{array}
  \]
  We say that $\meta{e}$ is \emph{closed} if $FV(\meta{e}) = \emptyset$.

  \vspace{3mm}

  \noindent\boxed{\meta{\Gamma} \vdash \meta{e} : \meta{\tau}}
  \begin{mathpar}
    \inferrule{ }{\meta{\Gamma} \vdash \meta{b} : bool}
    \and
    \inferrule{\meta{\Gamma} \vdash \meta{e_1} : bool \and \meta{\Gamma} \vdash \meta{e_2} : \meta{\tau}\and \meta{\Gamma} \vdash\meta{e_3} : \meta{\tau} }
              {\meta{\Gamma} \vdash \progif\ \meta{e_1}\ \progthen\ \meta{e_2}\ \progelse\ \meta{e_3} : \meta{\tau}}
    \and
    \inferrule{\meta{x} \in \dom{\meta{\Gamma}} \and \meta{\Gamma}(\meta{x}) = \meta{\tau}}{\meta{\Gamma} \vdash \meta{x} : \meta{\tau}}\\
    \and
    \inferrule{\meta{\Gamma}\vdash\meta{e_1}:\meta{\tau_1}\to\meta{\tau_2} \and \meta{\Gamma}\vdash\meta{e_2}:\meta{\tau_1}}
              {\meta{\Gamma}\vdash\meta{e_1}\ \meta{e_2}:\meta{\tau_2}}
    \and
    \inferrule{\meta{\Gamma}[\meta{x}\mapsto\meta{\tau_1}]\vdash\meta{e}:\meta{\tau_2}}
              {\meta{\Gamma}\vdash\lambda\meta{x}.\,\meta{e}:\meta{\tau_1}\to\meta{\tau_2}}
  \end{mathpar}
\end{document}